<div id="app">
  <h1>pat           ch</h1>
  <p>{{foo}}</p>
  <div>
    <div></div>
    <div>bar</div>
    <div>{{bar}}</div>
  </div>
  <Comp></Comp>
  <ul>
    <li v-for="(arr, index) in arrs" :key="index">
      {{ arr }}
    </li>
  </ul>
</div>
<script src="../dist/vue.global.js"></script>
<script>
  const { createApp, reactive } = Vue

  const app = createApp({
    data() {
      return {
        foo: 'foo',
        arrs: [1,2,3,4,5,6,7,8,9],
        bar: 'bar'
      }
    },
  }).component('Comp', {template: '<div>I am comp</div>'}).mount('#app')
</script>


<!-- patch Array -->
<!-- <div id="app">
  <div v-for="(item,index) in arrs">{{item}}</div>
</div>
<script src="../dist/vue.global.js"></script>
<script>
  const {createApp} = Vue

  createApp({
    data() {
      return {
        arrs: ['a', 'b', 'c', 'd']
      }
    },

    mounted () {
      setTimeout(() => {
        this.arr.splice(1, 0, 'e')
      }, 1000)
    }
  })
</script> -->

<script>
  /**
   * 编译器原理 tamplate => ast => render
   * 1. 解析-parse 解析字符串template为抽象语法树ast
   * 2. 转换-transform 解析属性、样式、指令等
   * 3. 生成-gendrate 将ast转化为渲染函数
   */

  /* function add() {
    // 第一次执行时，定义一个数组专门用来存储所有的参数
    var _args = [].slice.call(arguments);
    // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值,执行时已经收集所有参数为数组
    var adder = function () {
      var _adder = function () {
        // 执行收集动作，每次传入的参数都累加到原参数
        [].push.apply(_args, [].slice.call(arguments));
        return _adder;
      };
      // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
      _adder.toString = function () {
        return _args.reduce(function (a, b) {
          return a + b;
        });
      }
      return _adder;
    }
    return adder(_args);
  }
  console.log(add(1)(2).toString()) */
</script>