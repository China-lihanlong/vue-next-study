<div id="app">
  <div>{{ count }}</div>
  <button @click="addCount">count++</button>
  <comp :count="count"></comp>
  {{ username }}
  <input type="text" v-model="count" />
  <!-- <comp>
    <template v-slot:default="slotProps">
      <div>{{slotProps.state}}</div>
    </template>
  </comp> -->
</div>
<script src="../dist/vue.global.js"></script>
<script>
  const { createApp, ref, reactive } = Vue
  const App = {
    props: ['username'],

    setup() {
      const count = ref(0)
      function addCount() {
        count.value++
      }
      return {
        count,
        addCount
      }
    }
  }
  const comp = {
    template:
      `
     <div>
       {{ count }}
     </div>
     `,
    props: {
      count: Number
    },
    setup() {
      const state = reactive([1, 2, 3, 4, 5, 6])
      return {
        state
      }
    }
  }
  const app = createApp(App, {
    username: 'xxxx'
  }).component('comp', comp).mount('#app')
</script>

<!-- <script>
  const _Vue = Vue
  const { createElementVNode: _createElementVNode } = _Vue

  const _hoisted_1 = ["onClick"]

  return function render(_ctx, _cache) {
    with (_ctx) {
      const { toDisplayString: _toDisplayString, createElementVNode: _createElementVNode, Fragment: _Fragment, openBlock: _openBlock, createElementBlock: _createElementBlock } = _Vue

      return (_openBlock(), _createElementBlock(_Fragment, null, [
        _createElementVNode("div", null, _toDisplayString(count), 1 /* TEXT */),
        _createElementVNode("button", { onClick: addCount }, "count++", 8 /* PROPS */, _hoisted_1)
      ], 64 /* STABLE_FRAGMENT */))
    }
  }
</script> -->


<script>


/**
 * DOM diff流程
 * 在之前的setupRenderEffect函数中，产生过一个函数 componentUpdateFn 通过ReactiveEffect将其和数据产生了依赖关系
 * 在数据更新之后，就会重新执行,但是不是直接执行 componentUpdateFn，而是执行调度函数(在每一个数据身上的effect有调度
 * 函数都会去调用，不是直接执行更新更新器)
 * 
 * 调度函数执行的是queueJob 作用是把更新器放入同步任务队列(是一个微任务队列) 
 * 在更新器内部是调用流程是 run() => componentUpdateFn() => (先调用渲染render产生新的VNode)patch()
 * 
 * 在更新阶段 第一次进入patch肯定是Fragment(或者称之为块) 调用 processFragment() 调用 patchBlockChildren()(patchBlockChildren
 * 的作用是遍历Fragment(或者称之为块)中的每一个元素进行对比还是调用patch)
 * 第二次进入patch 就可以对比节点(元素文本啥的)
 */

</script>